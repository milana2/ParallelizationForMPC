def cryptonets_max_pooling(vals_0, cols_0, rows_0, cols_res_0, rows_res_0, OUTPUT_res_0):
    # Shared array declarations
    _1_3 = _v.sbool.Tensor([rows_res_0, cols_res_0])
    _10_0 = sint.Tensor([rows_res_0, cols_res_0])
    _11_0 = sint.Tensor([rows_res_0, cols_res_0])
    _12_0 = sint.Tensor([rows_res_0, cols_res_0])
    _2_3 = _v.sbool.Tensor([rows_res_0, cols_res_0])
    _3_3 = _v.sbool.Tensor([rows_res_0, cols_res_0])
    _4_0 = sint.Tensor([rows_res_0, cols_res_0])
    _5_0 = sint.Tensor([rows_res_0, cols_res_0])
    _6_0 = sint.Tensor([rows_res_0, cols_res_0])
    _7_0 = sint.Tensor([rows_res_0, cols_res_0])
    _8_0 = sint.Tensor([rows_res_0, cols_res_0])
    _9_0 = sint.Tensor([rows_res_0, cols_res_0])
    OUTPUT_res_3 = sint.Tensor([rows_res_0, cols_res_0])
    max_3 = sint.Tensor([rows_res_0, cols_res_0])
    max_4 = sint.Tensor([rows_res_0, cols_res_0])
    max_5 = sint.Tensor([rows_res_0, cols_res_0])
    max_6 = sint.Tensor([rows_res_0, cols_res_0])
    max_7 = sint.Tensor([rows_res_0, cols_res_0])
    max_8 = sint.Tensor([rows_res_0, cols_res_0])
    max_9 = sint.Tensor([rows_res_0, cols_res_0])
    # Function body
    _4_0 = _v.lift(lambda indices: OUTPUT_res_0, [rows_res_0, cols_res_0])
    _6_0 = _v.lift(lambda indices: (vals_0[(((indices[0] * 2) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])
    _7_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])
    _8_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])
    _9_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])
    _10_0 = _v.lift(lambda indices: (vals_0[((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2))]), [rows_res_0, cols_res_0])
    _11_0 = _v.lift(lambda indices: (vals_0[(((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])
    _12_0 = _v.lift(lambda indices: (vals_0[(((((indices[0] * 2) + 1) * cols_0) + (indices[1] * 2)) + 1)]), [rows_res_0, cols_res_0])
    _5_0 = _v.lift(lambda indices: _v.vectorized_access(_4_0, [None, None]), [rows_res_0, cols_res_0])
    _v.vectorized_assign(max_3, [None, None], _v.vectorized_access(_6_0, [None, None]))
    _v.vectorized_assign(max_4, [None, None], _v.vectorized_access(_8_0, [None, None]))
    _v.vectorized_assign(max_6, [None, None], _v.vectorized_access(_10_0, [None, None]))
    _v.vectorized_assign(max_8, [None, None], _v.vectorized_access(_12_0, [None, None]))
    _v.vectorized_assign(_1_3, [None, None], (_v.vectorized_access(_7_0, [None, None]) > _v.vectorized_access(max_3, [None, None])))
    _v.vectorized_assign(max_5, [None, None], _v.vectorized_access(_1_3, [None, None]).if_else(_v.vectorized_access(max_4, [None, None]), _v.vectorized_access(max_3, [None, None])))
    _v.vectorized_assign(_2_3, [None, None], (_v.vectorized_access(_9_0, [None, None]) > _v.vectorized_access(max_5, [None, None])))
    _v.vectorized_assign(max_7, [None, None], _v.vectorized_access(_2_3, [None, None]).if_else(_v.vectorized_access(max_6, [None, None]), _v.vectorized_access(max_5, [None, None])))
    _v.vectorized_assign(_3_3, [None, None], (_v.vectorized_access(_11_0, [None, None]) > _v.vectorized_access(max_7, [None, None])))
    _v.vectorized_assign(max_9, [None, None], _v.vectorized_access(_3_3, [None, None]).if_else(_v.vectorized_access(max_8, [None, None]), _v.vectorized_access(max_7, [None, None])))
    _v.vectorized_assign(_5_0, [None, None], _v.vectorized_access(max_9, [None, None])); _v.vectorized_assign(OUTPUT_res_3, [None, None], _v.vectorized_access(_5_0, [None, None]))
    return OUTPUT_res_3
