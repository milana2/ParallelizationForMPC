def minimal_points(X_coords_0, Y_coords_0, N_0, result_X_0, result_Y_0):
    # Shared array declarations
    _10_0 = _v.sbool.Tensor([N_0, N_0])
    _11_0 = sint.Tensor([N_0, N_0])
    _12_0 = sint.Tensor([N_0, N_0])
    _13_0 = sint.Tensor([N_0, N_0])
    _14_0 = sint.Tensor([N_0, N_0])
    _15_0 = _v.sbool.Tensor([N_0])
    _16_0 = sint.Tensor([N_0])
    _17_0 = sint.Tensor([N_0])
    _3_3 = _v.sbool.Tensor([N_0, N_0])
    _4_3 = _v.sbool.Tensor([N_0, N_0])
    _5_3 = _v.sbool.Tensor([N_0, N_0])
    _6_2 = _v.sbool.Tensor([N_0])
    _8_0 = sint.Tensor([N_0])
    _9_0 = sint.Tensor([N_0])
    bx_3 = _v.sbool.Tensor([N_0, N_0])
    bx_4 = _v.sbool.Tensor([N_0, N_0])
    result_X_2 = sint.Tensor([N_0])
    result_Y_2 = sint.Tensor([N_0])
    val_X_2 = sint.Tensor([N_0])
    val_X_3 = sint.Tensor([N_0])
    val_X_4 = sint.Tensor([N_0])
    val_Y_2 = sint.Tensor([N_0])
    val_Y_3 = sint.Tensor([N_0])
    val_Y_4 = sint.Tensor([N_0])
    # Function body
    _8_0 = _v.lift(lambda indices: result_X_0, [N_0])
    _9_0 = _v.lift(lambda indices: result_Y_0, [N_0])
    _16_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0])
    _17_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0])
    bx_2 = _v.sbool(False)
    _11_0 = _v.lift(lambda indices: (X_coords_0[indices[1]]), [N_0, N_0])
    _12_0 = _v.lift(lambda indices: (X_coords_0[indices[0]]), [N_0, N_0])
    _13_0 = _v.lift(lambda indices: (Y_coords_0[indices[1]]), [N_0, N_0])
    _14_0 = _v.lift(lambda indices: (Y_coords_0[indices[0]]), [N_0, N_0])
    val_X_2[:] = _8_0[:]
    val_Y_2[:] = _9_0[:]
    val_X_3[:] = _16_0[:]
    val_Y_3[:] = _17_0[:]
    _10_0 = _v.lift(lambda indices: bx_2, [N_0, N_0])
    _v.vectorized_assign(_3_3, [None, None], (_v.vectorized_access(_11_0, [None, None]) < _v.vectorized_access(_12_0, [None, None])))
    _v.vectorized_assign(_4_3, [None, None], (_v.vectorized_access(_13_0, [None, None]) < _v.vectorized_access(_14_0, [None, None])))
    _v.vectorized_assign(_5_3, [None, None], _v.vectorized_access(_3_3, [None, None]).bit_and(_v.vectorized_access(_4_3, [None, None])))
    for _18_0 in range(0, N_0):
        # Set ϕ value
        if _18_0 == 0:
            _v.vectorized_assign(bx_3, [None, _18_0], _v.vectorized_access(_10_0, [None, _18_0]))
        else:
            _v.vectorized_assign(bx_3, [None, _18_0], _v.vectorized_access(bx_4, [None, (_18_0 - 1)]))
        _v.vectorized_assign(bx_4, [None, _18_0], OR(_v.vectorized_access(bx_3, [None, _18_0]), _v.vectorized_access(_5_3, [None, _18_0])))
    # Loop exit ϕ values
    _v.vectorized_assign(bx_3, [None, _18_0], _v.vectorized_access(bx_4, [None, (_18_0 - 1)]))
    _15_0[:] = _v.drop_dim(bx_4)
    _6_2[:] = (_15_0[:].bit_not())
    val_X_4[:] = _6_2[:].if_else(val_X_3[:], val_X_2[:])
    val_Y_4[:] = _6_2[:].if_else(val_Y_3[:], val_Y_2[:])
    _8_0[:] = val_X_4[:]; result_X_2[:] = _8_0[:]
    _9_0[:] = val_Y_4[:]; result_Y_2[:] = _9_0[:]
    _7_1 = (result_X_2,result_Y_2,)
    return _7_1
