def inner_product(A_0, B_0, N_0):
    # Shared array declarations
    _1_0 = sint.Tensor([N_0])
    _2_0 = sint.Tensor([N_0])
    _3_0 = sint.Tensor([N_0])
    sum_2 = sint.Tensor([N_0])
    sum_3 = sint.Tensor([N_0])
    temp_2 = sint.Tensor([N_0])
    # Function body
    sum_1 = sint(0)
    _2_0[:] = _v.lift(lambda indices: (A_0[indices[0]]), [N_0])
    _3_0[:] = _v.lift(lambda indices: (B_0[indices[0]]), [N_0])
    _1_0[:] = _v.lift(lambda indices: sum_1, [N_0])
    temp_2[:] = (_2_0[:] * _3_0[:])
    for _5_0 in range(0, N_0):
        # Set ϕ value
        if _5_0 == 0:
            sum_2[_5_0] = _1_0[_5_0]
        else:
            sum_2[_5_0] = sum_3[(_5_0 - 1)]
        sum_3[_5_0] = (sum_2[_5_0] + temp_2[_5_0])
    # Loop exit ϕ values
    sum_2[_5_0] = sum_3[(_5_0 - 1)]
    _4_0 = _v.drop_dim(sum_3)
    return _4_0
